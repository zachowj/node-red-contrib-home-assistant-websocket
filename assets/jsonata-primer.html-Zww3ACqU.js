import{_ as t,c as a,b as o,o as n}from"./app-CrEJ5uQ_.js";const r={};function i(s,e){return n(),a("div",null,[...e[0]||(e[0]=[o(`<h1 id="jsonata-primer" tabindex="-1"><a class="header-anchor" href="#jsonata-primer"><span>JSONata primer</span></a></h1><p>This is a <em>simple introduction</em> highlighting the <em>key aspects</em> of this language. Full details can be found at the online <a href="https://docs.jsonata.org/overview" target="_blank" rel="noopener noreferrer">JSONata documentation</a></p><p><strong>JSONata</strong> code can be written as either a <em>single line expression</em>, or as multiple line expressions in a <em>code block</em> <code>( )</code>. Expressions are evaluated against a _JSON object. In Node-RED this object is the node input message.</p><p>A single line expression is evaluated left to right <em>by operator</em>, and the result returned is the final evaluation.</p><ul><li>Everything in JSONata is an <em>expression</em> and will be evaluated, returning the result</li><li>Literals are evaluated as themselves, but must be valid JSON (number, string, Boolean, null, array or object)</li><li>Object keys (fields) are evaluated as the key value, where found, thus <code>payload</code> will return the value contained in <code>msg.payload</code></li><li>The primary use of JSONata is to evaluate a JSON <em>path</em>, such as <code>msg.payload.foo.bar</code></li><li>Path operators are evaluated in a line expression by being applied to the top level message <ul><li><code>.</code> is the mapping (iteration) operator</li><li><code>[ ]</code> is the filter (selection) operator</li><li><code>{ }</code> is the reduce (aggregation) operator</li><li><code>^( )</code> is the sorting (ordering) operator</li></ul></li></ul><p><strong>Context:</strong> At the start of a line expression, the <em>context</em> is the entire top level message. Each path operator takes input from the current context, with the final result of each operation passed as output context to the next operator. Available context therefore changes as the evaluation proceeds. The current context at a specific point can be referred to using <code>$</code>. An additional operator <code>$$</code> can be used to refer to the top level context at any point, and <code>%</code> can be used to refer to the parent context (back one level) but only where this is possible to determine.</p><h2 id="the-mapping-iteration-operator" tabindex="-1"><a class="header-anchor" href="#the-mapping-iteration-operator"><span>The mapping (iteration) operator <code>.</code></span></a></h2><p>Syntax can be considered as <code>&lt;sequence-list&gt; . &lt;expression&gt;</code>.</p><p>The current <em>input-context</em> on the left hand side of the operator is parsed as a <em>sequence</em> or ordered list of items (for an array this is a list of the array elements, for an object or for a primitive this is usually a singleton list). Each item in this list is taken in sequence as the <em>evaluation-context</em>, and evaluated by the expression formed from the right hand side of the operator. The <em>result sequence</em> is then collated into an output array (from an input list) or returned as a singleton (from an input singleton, or where the input sequence reduces to a singleton).</p><p>As an example, <code>$type(payload)</code> returns the type of the message payload, however <code>payload.$type($)</code> returns an array of the type of each <em>element</em> within payload. For an array of numbers, this would be <code>[&quot;number&quot;, &quot;number&quot;, &quot;number&quot;]</code>. The right hand side, <code>$type()</code> is a JSONata function requiring a parameter. For many functions one or more parameters are optional, and where omitted they take the current (evaluation) context <code>$</code> instead. In this case, the parameter is not optional, hence the use of <code>$</code> for the immediate context (each array element in turn).</p><p><strong>Index operator <code>#</code>:</strong> Applied with the mapping operator, the <code>#</code> <em>index</em> operator can be used to capture the iteration index value for use later in the expression. The operator must be followed by a variable, for example <code>$i</code>, and this variable is made available for the remaining line expression. If <code>payload</code> is an array of three items, then <code>payload#$i.($i+2)</code> would return <code>[2, 3, 4]</code>. The use of <code>()</code> here is required since JSONata is left-associative and the parentheses are required to force the correct order of evaluation.</p><p><strong>Wildcards and array flattening:</strong> Within a path expression, <code>*</code> can be used to select all fields in an object, and <code>**</code> is a descendant wildcard for any depth of nesting. Thus <code>payload.**.time</code> would return an array of the values of all nested <em>time</em> keys.</p><p>The path expression may generate an array of arrays for the evaluation sequence list. In this case, the list will always first be flattened to just one array. This flattening also occurs for output when the result is an arrays of arrays.</p><p>If payload is an array of objects then <code>payload.$keys()</code> returns an array, listing the keys names for each array object. For an array of nested objects, <code>payload.**.$keys()</code> returns a flattened array of all keys. To remove duplicates, the <code>$distinct()</code> function can be used, thus <code>$distinct(payload.**.$keys())</code> returns an array of every key in message payload to any depth.</p><h2 id="the-filter-selection-operator" tabindex="-1"><a class="header-anchor" href="#the-filter-selection-operator"><span>The filter (selection) operator <code>[ ]</code></span></a></h2><p>The <code>[ ]</code> operator has several applications.</p><ul><li>If the operator encloses an <em>integer</em>, this acts as <strong>array index addressing</strong>, where <code>payload[0]</code> returns the first item in the array, <code>[-1]</code> the last item. Note that the index can be an integer, or any number expression that returns or rounds down to an integer.</li><li>If the operator encloses an <em>array of integers</em>, these act as a <strong>selection list</strong>, thus <code>payload[0, -1]</code> returns the first and last items from payload array.</li><li>Otherwise, where the operator encloses a <em>predicate expression</em>, this will map over the current context as a list, <strong>filtering</strong> only the list items where the predicate evaluates as true. For example <code>payload[time&lt;&quot;12:00&quot;]</code> where <code>time</code> is a key value within <code>payload</code> object.</li><li>For the special <strong>range operator</strong> <code>[a..b]</code>, such as <code>[0..3]</code> this syntax generates an array of integers between the two given integer values. Note that, as in all cases in JSONata, the defining integer values can be either literals, or expressions that evaluate to an integer. To generate an array of integers to be used as a filter requires <code>[[a..b]]</code>.</li><li>Lastly, this operator acts as an <strong>array constructor</strong>. <code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code> is an array. The simple form <code>[]</code> may also be used at any point in a line expression to force singleton output to an array, as in <code>payload.data[]</code>.</li></ul><p>JSONata does not inherently regard singleton values as fundamentally different to arrays. Although a singleton is a value without enclosing structure, path expressions that require an array input can accept a singleton, which is treated as an array of one item. In some situations, particularly with path input or output list flattening, it may be necessary to add an additional <code>[]</code> to the expression to ensure correct evaluation, and where an array of arrays is required in the result.</p><p><strong>No result means <em>nothing</em> is returned:</strong> One of the more unusual aspects of JSONata is the behaviour when an expression evaluates to <em>no discernible result</em>. Simply put, JSONata will neither return a value, nor <code>null</code> nor an error message where there is no result from an expression. Mistyping <code>paylaod</code> or requesting an array index <code>payload[100]</code> for an array of only 25 items will return <strong>nothing</strong>. This can make writing, testing and debugging JSONata code challenging, but it eliminates the need to code for exception conditions - declare what you want, and nothing else will be returned.</p><p>The filter operator binds more strongly than the mapping operator. This means that <code>payload.array[0]</code> is returned as an array of the first items in each <code>payload.array</code> and not the first item in the <code>payload.array</code> array result. Use <code>(payload.array)[0]</code> to force evaluation in a different order.</p><h2 id="the-reduce-aggregation-operator" tabindex="-1"><a class="header-anchor" href="#the-reduce-aggregation-operator"><span>The reduce (aggregation) operator <code>{ }</code></span></a></h2><p>This operator can only be used once in an expression line, and should ideally be at the very end. Note that <code>{ }</code> is a valid empty object, and <code>{&quot;key&quot;: &quot;value&quot;}</code> is a one-field object as expected. Both the key as well as the value can be any expression, thus<code>{last_updated: payload.state}</code> will generate a valid object as long as <code>last_updated</code> results in a string value. Naturally values may be an valid JSON type, including objects and arrays.</p><p>It is worth noting that in a key-value pair where the value is an expression that returns nothing, the key-value pair will not be returned in the result.</p><p>Thus <code>{&quot;key&quot;: &quot;value&quot;, &quot;result&quot;: [1, 2][4]}</code> will just return <code>{&quot;key&quot;: &quot;value&quot;}</code></p><h2 id="the-order-by-sort-operator" tabindex="-1"><a class="header-anchor" href="#the-order-by-sort-operator"><span>The order-by (sort) operator <code>^( )</code></span></a></h2><p>Applies to arrays, and will sort the array by one or more expressions, where the expression results in either a string or an number. Sorting is ascending <code>&lt;</code> by default, but can be modified to descending <code>&gt;</code>. Where <code>payload</code> is an array of objects, then <code>payload^(&gt;field, second)</code> will sort the array, by the <code>field</code> value, in descending order, and for equal values, additionally by the <code>second</code> field in ascending order. To sort an array of primitives such as strings, use the context variable <code>$</code>. If <code>payload</code> is an object, <code>$keys(payload)^($)</code> returns an array of the object keys sorted into alphabetic order.</p><h2 id="other-operators" tabindex="-1"><a class="header-anchor" href="#other-operators"><span>Other Operators</span></a></h2><p>JSONata is built on JavaScript, so much of the syntax and basic functions will be familiar. The usual mathematical operators apply.</p><p>Comparison operators are as expected, and also the <code>in</code> inclusion operator where <code>&quot;b&quot; in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code> returns <code>true</code>.</p><p>Boolean operators are the usual <code>and</code> and <code>or</code>, but <em>not</em> is provided as a function <code>$not()</code>.</p><p>String concatenation operator is <code>&amp;</code>, which provides the only situation where type is cast. Numbers, Boolean, arrays and objects are all stringified as required. Hence <code>payload &amp; &quot;&quot;</code> will turn an object to a stringified equivalent.</p><p>Conditional testing is a ternary operator, syntax as <code>&lt;test expression&gt; ? &lt;true expression&gt; : &lt;false expression&gt;</code> which returns the result of either the true or false expression. False expression is optional, and if omitted a false test expression result will return nothing. Nested conditionals evaluate as expected although the use of parentheses can help visual clarity or to change order.</p><h2 id="variables" tabindex="-1"><a class="header-anchor" href="#variables"><span>Variables</span></a></h2><p>JSONata permits the use of variables, although some care needs to be exercised in their use. Variables are named as <code>$name</code> and assigned using <code>$name:= &lt;expression&gt;</code>. Scope is from first declaration when assigned, and lasts for the enclosing line, code block <code>( )</code>, or nested blocks.</p><p>Variables in JSONata are <em>not values held in memory-allocated space</em> but rather <em>bindings</em>. In effect this means that variables can only be assigned, then referred to. Once assigned, further references to the variable are replaced at evaluation with the originally evaluated value at assignment. In practice, this means that</p><ul><li>The left hand side of <code>:=</code> assignment can only be a variable <code>$name</code>, and therefore-</li><li>Variables cannot be modified, only re-assigned</li><li>The value of an assignment is the value assigned, thus <code>$a:=3</code> returns 3</li></ul><p>Variable use should be avoided in single line expressions and only used in code blocks. Whilst expression lines are evaluated in order of the operators, left to right, JSONata execution is asynchronous and different parts of the expression may be prepared in any order. Any later reference to a variable in an expression may be evaluated <em>prior</em> to an earlier assignment in the same line. It also worth noting that, all variable and object field references are evaluated at the very start of statement execution. Nothing done during the expression execution can reliably update or change these values. For example: <code>[$a:=3 .. $b:=6].{&quot;result&quot;: $a:=$a+$b, &quot;next&quot;: $a}</code> may or may not work as expected.</p><h2 id="functions" tabindex="-1"><a class="header-anchor" href="#functions"><span>Functions</span></a></h2><p>JSONata has a wide range of inbuilt functions (see documentation) for manipulating:</p><ul><li>strings</li><li>numbers</li><li>aggregation (sum, average)</li><li>arrays</li><li>objects</li><li>time (limited to date-time string &lt;-&gt; Unix millisecond)</li></ul><p>There are also several higher-order functions, such as <code>$map()</code> and <code>$reduce()</code> which apply a mapping function over an array, and similarly with result accumulation.</p><p>Functions can be nested, so that</p><p><code>$substringAfter($substringBefore(&quot;2024-01-10T10:32:14.0324&quot;,&quot;.&quot;),&quot;T&quot;)</code> returns just the time part of the string.</p><p>The <em>function chaining</em> operator <code>~&gt;</code> allows for greater visual clarity</p><p><code>$substringBefore(&quot;2024-01-10T10:32:14.0324&quot;,&quot;.&quot;) ~&gt; $substringAfter(&quot;T&quot;)</code>.</p><p>This works with the function chain passing the result as context, and subsequent functions permitting an optional parameter to be substituted by this context.</p><p><strong>Additional features:</strong> Regex is available in JSONata. The usual regex format <code>/regular_expression/flags</code> applies, and this can be used in the functions $match(), $contains(), $split() and $replace(). In addition, a regex expression can be used <em>as a function</em>.</p><p><code>$join($entities().*[state = &quot;on&quot; and entity_id ~&gt; /^light|^switch/].attributes.friendly_name, &quot;, &quot;)</code></p><ul><li><code>$entities()</code> returns an object containing all Home Assistant entities, each <em>key</em> being an entity id, and <em>value</em> being an object with details of that entity</li><li><code>.*</code> maps over the object matching all keys, therefore returning an array of all entities</li><li><code>[]</code> filters out the entities that match the predicate expression, using <ul><li><code>state = &quot;on&quot;</code> to match all entities with state &#39;on&#39;</li><li><code>entity_id ~&gt; /^light|^switch/</code> generates a function from the regex expression &quot;match any string containing &#39;light&#39; or &#39;switch&#39;&quot;. Each <code>entity_id</code> is passed to this function, which</li><li>returns a Boolean true or false, and</li><li>when both parts of the predicate expression are true, the entity is selected (otherwise the entity is not returned in the result)</li></ul></li><li>the result of this is an array of <em>selected entities</em></li><li>the field <code>attributes.friendly_name</code> is picked out, resulting in an array of <em>friendly names</em> for all lights / switches left on</li><li>then the <code>$join()</code> function joins each item in the array, using &quot;, &quot; as the separator, and returning a string</li></ul><p>Note that the <code>$entities()</code> function is a special function added just to the WebSocket nodes.</p><p>Note that entity id names are made up from a domain (platform / integration) and name, separated by <code>.</code>. This is potentially confusing as the object key becomes <code>person.george</code>. Where object keys contain spaces and special characters, the <code>payload.&#39;person.george&#39;</code> referencing syntax has to be used.</p><p><strong>User defined functions:</strong> User functions can be easily defined and assigned to a variable name using the syntax</p><p><code>$fname:= function(arg){&quot;Result Is &quot; &amp; arg}</code>.</p><p>Once defined the function can be called using <code>$fname(parmValue)</code> from later within the enclosing code block.</p><h2 id="code-blocks" tabindex="-1"><a class="header-anchor" href="#code-blocks"><span>Code blocks</span></a></h2><p>To breakout from the constraints of just a single line expression, JSONata permits the use of <code>(expression; expression)</code> code blocks. These start and end with <code>( )</code> and contain one or more line expressions terminated by <code>;</code>. The return value of the block is the return of the execution result of the very last line.</p><p>Using code blocks permits a much richer coding experience, allowing the use of variable and function definitions.</p><h2 id="how-it-works-in-practice" tabindex="-1"><a class="header-anchor" href="#how-it-works-in-practice"><span>How it works in practice</span></a></h2><p>The following expression takes an object in payload and re-sorts the object keys alphabetically.</p><p><code>$keys(payload)^($).{$:$lookup($$.payload,$)}~&gt;$merge()</code></p><p>This works by</p><ul><li>using <code>$keys()</code> to obtain an array of key name strings from the object in payload <ul><li>sorting this array alphabetically</li></ul></li><li>mapping over the sorted array of keys, creating a new object for each key</li><li>with the context (each key in the iteration) as the new object key</li><li>and using <code>$lookup(object, key)</code> to find the value of this key, as the new object value <ul><li>where <code>$$.payload</code> refers back to the <code>$$</code> <em>top level</em> context to reach <code>payload</code>, and <code>$</code> the <em>current</em> context (the key in each iteration)</li></ul></li><li>thus producing an result array with each new key:object pair (in the new order)</li><li>and then using <code>$merge()</code> to merge this array of objects back into one object</li></ul><p>The simplicity comes from the power of JSONata to map, filter, sort and aggregate, however compared to most procedural languages it is a new way of thinking. Since the JSON object and variables cannot be modified, there is the question of how to, for example, change just one element in an array. The expression <code>$array[2]:=10</code> will return an error since the left hand side of assignment can <em>only</em> be a variable and not an expression. To achieve this requires a <em>declaration</em> of the new array, built as follows.</p><div class="language-jsonata" data-highlighter="prismjs" data-ext="jsonata" data-title="jsonata"><pre><code><span class="line">  (</span>
<span class="line">    $array:=[1, 2, 3, 4, 5, 6];</span>
<span class="line">    $newval:=10;</span>
<span class="line">    $index:=2;</span>
<span class="line">    $append($array[[0..$index-1]], $newval)~&gt;$append($array[[$index+1..$count($array)]])</span>
<span class="line">  )</span>
<span class="line"></span></code></pre></div><p>Here we declare the result to be the first part of the array up to the new value, the new value, then the remainder of the array. You may note that <code>$count($array)</code> is incorrect being one greater than the end index, however as JSONata does not complain when accessing beyond the array length, this point can be relaxed.</p><p><strong>It is worth noting</strong> that it is not necessary to refer to the input JSON document. The following expression generates an array of 24 objects. <code>([1..24])#$pos.{&quot;index&quot;: $, &quot;hour&quot;: $formatInteger($pos, &quot;09&quot;) &amp; &quot;:00&quot;}</code></p><p><strong>Declarative functional programming for objects:</strong> Given an object in msg.payload, how then do we change just one field value, since <code>payload.field:=&quot;new value&quot;</code> is <em>not</em> permitted? The answer is that we have to write a &quot;function&quot; that declares - that is, returns - the result we require, with the idea that JSONata expressions are functions applied to the input JSON object.</p><p>The <code>$spread()</code> function takes a JSON object and returns an array of objects, each with a single key:value pair. The <code>$merge()</code> function reverses this, taking an array of objects and combining back into one object. A particular feature of this function is that, where key values are duplicated, the end result contains only the <em>last</em> such key to be found. Therefore, the approach to take is to spread the object, append the replacement key:value as an object to the end of this array, then to merge the array back together.</p><div class="language-jsonata" data-highlighter="prismjs" data-ext="jsonata" data-title="jsonata"><pre><code><span class="line"> (</span>
<span class="line">   $object:={&quot;first&quot;: 1, &quot;second&quot;: 2, &quot;third&quot;: 3};</span>
<span class="line">   $replaceKey:= &quot;second&quot;;</span>
<span class="line">   $replaceVal:= 15;</span>
<span class="line">   $spread($object) ~&gt; $append({$replaceKey: $replaceVal}) ~&gt; $merge()</span>
<span class="line"> )</span>
<span class="line"></span></code></pre></div><p>Deeply nested objects are much more complex, as the entire tree has to be unpicked and rebuilt in order. Fortunately there is a special function that can perform <a href="https://docs.jsonata.org/other-operators#-------transform" target="_blank" rel="noopener noreferrer">transformation</a> on an object for us. <code>$object ~&gt; | $ | {&quot;second&quot;: 15} |</code></p><h2 id="errors-and-error-handling" tabindex="-1"><a class="header-anchor" href="#errors-and-error-handling"><span>Errors and error handling</span></a></h2><p>JSONata has minimal error management. Errors occur at compile time when editing due to incorrect syntax, and will show as red line box in the UI input field, as well as a red triangle on the node. Common reasons for this are missing:</p><ul><li><code>&amp;</code> between string concatenation</li><li><code>:</code> in conditional testing, or in object construction</li><li><code>;</code> line terminators</li></ul><p>Errors at run time are mostly limited to passing nothing or an incorrect type as parameter to a function. The <code>$number()</code> function accepts a string and returns a JSON number, but only where the input can be correctly parsed. JSON numbers must only contain numbers throughout. Passing <code>&quot;12,34a&quot;</code> will generate a fatal error, and the entire expression evaluation will be aborted.</p><p>Where functions <em>explicitly</em> require an array, passing singletons will generate an error, and thus the use of <code>[ ]</code> to either construct arrays or cast singletons to an array may be required, for example <code>$append(payload.array, [$additional])</code>. Where necessary the use of <code>$exits()</code> to check for object fields, and the use of <code>$type()</code> can help.</p><h2 id="writing-jsonata-code" tabindex="-1"><a class="header-anchor" href="#writing-jsonata-code"><span>Writing JSONata code</span></a></h2><p>JSONata can be directly entered into any node where the UI field entry type is <strong>J: expression</strong>. The Node-RED editor permits expansion of the simple box using the &#39;...&#39; field at the end of the line. This editor provides more space, the ability to select and insert JSONata functions from a pick list, a formatting option, and a tab for testing. However, this can be limited and the <a href="https://try.jsonata.org" target="_blank" rel="noopener noreferrer">try JSONata</a> website is easier to use.</p><p>If using the JSONata Exerciser website, use a debug node set to output the &quot;complete message&quot;, copy this entire object and paste over the left hand side JSON input object (there is a useful formatter option). Test JSONata code can then be written in the top right hand window, and the result appears immediately below. Useful output messages indicate where there is an error in the input JSON, where no result is generated, or where an error has occurred.</p><p>Note that there are special Node-RED functions, <code>$env()</code> is one, that can be tested in the Node-RED editor, but not in <strong>try JSONata</strong>. The WebSocket functions, such as <code>$entity()</code> cannot be tested in either editor.</p><h2 id="what-jsonata-cannot-do" tabindex="-1"><a class="header-anchor" href="#what-jsonata-cannot-do"><span>What JSONata cannot do</span></a></h2><p>JSONata can almost completely replace JavaScript in function nodes. However, the simplicity and power of the declarative language is at the expense of efficiency. Arrays and files with more than, say, 500 elements or lines will require significant CPU processing as to temporarily halt Node-RED and potentially Home Assistant. The main barrier to use is more likely to be the time and effort required to generate code, since it can be challenging to think in terms of a functional <em>declaration</em>, the outcome of which is the required result, rather than the more usual approach of designing and writing an algorithm to <em>prescribe</em> how to obtain the required result.</p><p>Good luck.</p>`,82)])])}const c=t(r,[["render",i],["__file","jsonata-primer.html.vue"]]),d=JSON.parse('{"path":"/guide/jsonata/jsonata-primer.html","title":"JSONata primer","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"The mapping (iteration) operator .","slug":"the-mapping-iteration-operator","link":"#the-mapping-iteration-operator","children":[]},{"level":2,"title":"The filter (selection) operator [ ]","slug":"the-filter-selection-operator","link":"#the-filter-selection-operator","children":[]},{"level":2,"title":"The reduce (aggregation) operator { }","slug":"the-reduce-aggregation-operator","link":"#the-reduce-aggregation-operator","children":[]},{"level":2,"title":"The order-by (sort) operator ^( )","slug":"the-order-by-sort-operator","link":"#the-order-by-sort-operator","children":[]},{"level":2,"title":"Other Operators","slug":"other-operators","link":"#other-operators","children":[]},{"level":2,"title":"Variables","slug":"variables","link":"#variables","children":[]},{"level":2,"title":"Functions","slug":"functions","link":"#functions","children":[]},{"level":2,"title":"Code blocks","slug":"code-blocks","link":"#code-blocks","children":[]},{"level":2,"title":"How it works in practice","slug":"how-it-works-in-practice","link":"#how-it-works-in-practice","children":[]},{"level":2,"title":"Errors and error handling","slug":"errors-and-error-handling","link":"#errors-and-error-handling","children":[]},{"level":2,"title":"Writing JSONata code","slug":"writing-jsonata-code","link":"#writing-jsonata-code","children":[]},{"level":2,"title":"What JSONata cannot do","slug":"what-jsonata-cannot-do","link":"#what-jsonata-cannot-do","children":[]}],"git":{"updatedTime":1719788083000,"contributors":[{"name":"Jason","email":"37859597+zachowj@users.noreply.github.com","commits":1}]},"filePathRelative":"guide/jsonata/jsonata-primer.md"}');export{c as comp,d as data};
